/*
# Abstract Syntax Tree Interface

Typst's Abstract Syntax Tree (AST) is a lazy, typed view over the untyped
Concrete Syntax Tree (CST) and is rooted in the [`Markup`] node.

## The AST is a View

Most AST nodes are wrapper structs around [`SyntaxNode`] pointers. This summary
will use a running example of the [`Raw`] node type, which is declared (after
macro expansion) as: `struct Raw<'a>(&'a SyntaxNode);`.

[`SyntaxNode`]s are generated by the parser and constitute the Concrete Syntax
Tree (CST). The CST is _concrete_ because it has the property that an in-order
tree traversal will recreate the text of the source file exactly.

[`SyntaxNode`]s in the CST contain their [`SyntaxKind`], but don't themselves
provide access to the semantic meaning of their contents. That semantic meaning
is available through the Abstract Syntax Tree by iterating over CST nodes and
inspecting their contents. The format is prepared ahead-of-time by the parser so
that this module can unpack the abstract meaning from the CST's structure.

Raw nodes are parsed by recognizing paired backtick delimiters, which you will
find as CST nodes with the [`RawDelim`] kind. However, the AST doesn't include
these delimiters because it _abstracts_ over the backticks. Instead, the parent
raw node will only use its child [`RawDelim`] CST nodes to determine whether the
element is a block or inline.

## The AST is Typed

AST nodes all implement the [`AstNode`] trait, but nodes can also implement
their own unique methods. These unique methods are the "real" interface of the
AST, and provide access to the abstract, semantic, representation of each kind
of node. For example, the [`Raw`] node provides 3 methods that specify its
abstract representation: [`Raw::lines()`] returns the raw text as an iterator of
lines, [`Raw::lang()`] provides the optionally present [`RawLang`] language tag,
and [`Raw::block()`] gives a bool for whether the raw element is a block or
inline.

This semantic information is unavailable in the CST. Only by converting a CST
node to an AST struct will Rust let you call a method of that struct. This is a
safe interface because the only way to create an AST node outside this file is
to call  [`AstNode::from_untyped`]. The `node!` macro implements `from_untyped`
by checking the node's kind before constructing it, returning `Some()` only if
the kind matches. So we know that it will have the expected children underneath,
otherwise the parser wouldn't have produced this node.

## The AST is rooted in the [`Markup`] node

The AST is rooted in the [`Markup`] node, which provides only one method:
[`Markup::exprs`]. This returns an iterator of the main [`Expr`] enum. [`Expr`]
is important because it contains the majority of expressions that Typst will
evaluate. Not just markup, but also math and code expressions. Not all
expression types are available from the parser at every step, but this does
decrease the amount of wrapper enums needed in the AST (and this file is long
enough already).

Expressions also branch off into the remaining tree. You can view enums in this
file as edges on a graph: areas where the tree has paths from one type to
another (accessed through methods), then structs are the nodes of the graph,
providing methods that return enums, etc. etc.

## The AST is Lazy

Being lazy means that the untyped CST nodes are converted to typed AST nodes
only as the tree is traversed. If we parse a file and a raw block is contained
in a branch of an if-statement that we don't take, then we won't pay the cost of
creating an iterator over the lines or checking whether it was a block or
inline (although it will still be parsed into nodes).

This is also a factor of the current "tree-interpreter" evaluation model. A
bytecode interpreter might instead eagerly convert the AST into bytecode, but it
would still traverse using this lazy interface. While the tree-interpreter
evaluation is straightforward and easy to add new features onto, it has to
re-traverse the AST every time a function is evaluated. A bytecode interpreter
using the lazy interface would only need to traverse each node once, improving
throughput at the cost of initial latency and development flexibility.
*/

package syntax

import (
	"fmt"
	"path/filepath"
	"slices"
	"strconv"
	"strings"

	"github.com/mewmew/typast/internal/option"
	"github.com/mewmew/typast/internal/scanner"
	"github.com/mewmew/typast/internal/stdx"
	"github.com/pkg/errors"
)

// A typed AST node.
type AstNode interface {
	// Convert a node into its typed variant.
	from_untyped(node *SyntaxNode) option.Option[AstNode]

	// A reference to the underlying syntax node.
	to_untyped() *SyntaxNode

	//_default() AstNode
}

// The source code location.
//
// span
func AstNode_span(node AstNode) Span {
	return node.to_untyped().span()
}

// A generic interface for converting untyped nodes into typed AST nodes.

// Whether the node can be cast to the given AST node.
//
// is
func SyntaxNode_is[T AstNode](node *SyntaxNode) bool {
	return SyntaxNode_cast[T](node).IsPresent()
}

// Try to convert the node to a typed AST node.
//
// cast
func SyntaxNode_cast[T AstNode](node *SyntaxNode) option.Option[T] {
	var zero T
	//if _, ok := zero.(Expr); ok {
	//	return Expr_from_untyped(node)
	//}
	// HACK: unable to use type assertion with type parameter, so using string
	// representation hack instead :)
	type_name := fmt.Sprintf("%T", new(T))
	if type_name == "*syntax.Expr" {
		if expr, ok := Expr_from_untyped(node).Get(); ok {
			return option.Some[T](expr.(T))
		}
	}
	if _n, ok := zero.from_untyped(node).Get(); ok {
		n := _n.(T)
		return option.Some[T](n)
	}
	return option.None[T]()
}

// Find the first child that can cast to the AST type `T`.
//
// try_cast_first
func SyntaxNode_try_cast_first[T AstNode](node *SyntaxNode) option.Option[T] {
	for _, child := range node.children() {
		if c, ok := SyntaxNode_cast[T](child).Get(); ok {
			return option.Some(c)
		}
	}
	return option.None[T]()
}

// Find the last child that can cast to the AST type `T`.
//
// try_cast_last
func SyntaxNode_try_cast_last[T AstNode](node *SyntaxNode) option.Option[T] {
	children := node.children()
	for _, child := range slices.Backward(children) {
		if c, ok := SyntaxNode_cast[T](child).Get(); ok {
			return option.Some(c)
		}
	}
	return option.None[T]()
}

// Get the first child of AST type `T` or a placeholder if none.
//
// cast_first
func SyntaxNode_cast_first[T AstNode](node *SyntaxNode) T {
	if n, ok := SyntaxNode_try_cast_first[T](node).Get(); ok {
		return n
	}
	var zero T // default value (placeholder).
	return zero
}

// Get the last child of AST type `T` or a placeholder if none.
//
// cast_last
func SyntaxNode_cast_last[T AstNode](node *SyntaxNode) T {
	if n, ok := SyntaxNode_try_cast_last[T](node).Get(); ok {
		return n
	}
	var zero T // default value (placeholder).
	return zero
}

// TODO: move ast_node.go to here.

// --- [ Markup ] --------------------------------------------------------------

// The syntactical root capable of representing a full parsed document.
type Markup struct {
	*SyntaxNode
}

// The expressions.
func (node *Markup) exprs() []Expr {
	var exprs []Expr
	was_stmt := false
	for _, child := range node.children() {
		// Ignore newline directly after statements without semicolons.
		kind := child.kind()
		keep := !was_stmt || child.kind() != SyntaxKindSpace
		was_stmt = kind.IsStmt()
		if keep {
			if expr, ok := Expr_cast_with_space(child).Get(); ok {
				exprs = append(exprs, expr)
			}
		}
	}
	return exprs
}

// === [ Expr ] ================================================================

// An expression in markup, math or code.
type Expr interface {
	AstNode

	isExpr()
}

func (*Text) isExpr()               {}
func (*Space) isExpr()              {}
func (*Linebreak) isExpr()          {}
func (*Parbreak) isExpr()           {}
func (*Escape) isExpr()             {}
func (*Shorthand) isExpr()          {}
func (*SmartQuote) isExpr()         {}
func (*Strong) isExpr()             {}
func (*Emph) isExpr()               {}
func (*Raw) isExpr()                {}
func (*Link) isExpr()               {}
func (*Label) isExpr()              {}
func (*Ref) isExpr()                {}
func (*Heading) isExpr()            {}
func (*ListItem) isExpr()           {}
func (*EnumItem) isExpr()           {}
func (*TermItem) isExpr()           {}
func (*Equation) isExpr()           {}
func (*Math) isExpr()               {}
func (*MathText) isExpr()           {}
func (*MathIdent) isExpr()          {}
func (*MathShorthand) isExpr()      {}
func (*MathAlignPoint) isExpr()     {}
func (*MathDelimited) isExpr()      {}
func (*MathAttach) isExpr()         {}
func (*MathPrimes) isExpr()         {}
func (*MathFrac) isExpr()           {}
func (*MathRoot) isExpr()           {}
func (*Ident) isExpr()              {}
func (*None) isExpr()               {}
func (*Auto) isExpr()               {}
func (*Bool) isExpr()               {}
func (*Int) isExpr()                {}
func (*Float) isExpr()              {}
func (*Numeric) isExpr()            {}
func (*Str) isExpr()                {}
func (*CodeBlock) isExpr()          {}
func (*ContentBlock) isExpr()       {}
func (*Parenthesized) isExpr()      {}
func (*Array) isExpr()              {}
func (*Dict) isExpr()               {}
func (*Unary) isExpr()              {}
func (*Binary) isExpr()             {}
func (*FieldAccess) isExpr()        {}
func (*FuncCall) isExpr()           {}
func (*Closure) isExpr()            {}
func (*LetBinding) isExpr()         {}
func (*DestructAssignment) isExpr() {}
func (*SetRule) isExpr()            {}
func (*ShowRule) isExpr()           {}
func (*Contextual) isExpr()         {}
func (*Conditional) isExpr()        {}
func (*WhileLoop) isExpr()          {}
func (*ForLoop) isExpr()            {}
func (*ModuleImport) isExpr()       {}
func (*ModuleInclude) isExpr()      {}
func (*LoopBreak) isExpr()          {}
func (*LoopContinue) isExpr()       {}
func (*FuncReturn) isExpr()         {}

// cast_with_space
func Expr_cast_with_space(node *SyntaxNode) option.Option[Expr] {
	switch node.kind() {
	case SyntaxKindSpace:
		return option.Some[Expr](&Space{SyntaxNode: node})
	default:
		return Expr_from_untyped(node)
	}
}

// from_untyped
func Expr_from_untyped(node *SyntaxNode) option.Option[Expr] {
	switch node.kind() {
	case SyntaxKindSpace:
		return option.None[Expr]() // Skipped unless using `cast_with_space`.
	case SyntaxKindLinebreak:
		return option.Some[Expr](&Linebreak{SyntaxNode: node})
	case SyntaxKindParbreak:
		return option.Some[Expr](&Parbreak{SyntaxNode: node})
	case SyntaxKindText:
		return option.Some[Expr](&Text{SyntaxNode: node})
	case SyntaxKindEscape:
		return option.Some[Expr](&Escape{SyntaxNode: node})
	case SyntaxKindShorthand:
		return option.Some[Expr](&Shorthand{SyntaxNode: node})
	case SyntaxKindSmartQuote:
		return option.Some[Expr](&SmartQuote{SyntaxNode: node})
	case SyntaxKindStrong:
		return option.Some[Expr](&Strong{SyntaxNode: node})
	case SyntaxKindEmph:
		return option.Some[Expr](&Emph{SyntaxNode: node})
	case SyntaxKindRaw:
		return option.Some[Expr](&Raw{SyntaxNode: node})
	case SyntaxKindLink:
		return option.Some[Expr](&Link{SyntaxNode: node})
	case SyntaxKindLabel:
		return option.Some[Expr](&Label{SyntaxNode: node})
	case SyntaxKindRef:
		return option.Some[Expr](&Ref{SyntaxNode: node})
	case SyntaxKindHeading:
		return option.Some[Expr](&Heading{SyntaxNode: node})
	case SyntaxKindListItem:
		return option.Some[Expr](&ListItem{SyntaxNode: node})
	case SyntaxKindEnumItem:
		return option.Some[Expr](&EnumItem{SyntaxNode: node})
	case SyntaxKindTermItem:
		return option.Some[Expr](&TermItem{SyntaxNode: node})
	case SyntaxKindEquation:
		return option.Some[Expr](&Equation{SyntaxNode: node})
	case SyntaxKindMath:
		return option.Some[Expr](&Math{SyntaxNode: node})
	case SyntaxKindMathText:
		return option.Some[Expr](&MathText{SyntaxNode: node})
	case SyntaxKindMathIdent:
		return option.Some[Expr](&MathIdent{SyntaxNode: node})
	case SyntaxKindMathShorthand:
		return option.Some[Expr](&MathShorthand{SyntaxNode: node})
	case SyntaxKindMathAlignPoint:
		return option.Some[Expr](&MathAlignPoint{SyntaxNode: node})
	case SyntaxKindMathDelimited:
		return option.Some[Expr](&MathDelimited{SyntaxNode: node})
	case SyntaxKindMathAttach:
		return option.Some[Expr](&MathAttach{SyntaxNode: node})
	case SyntaxKindMathPrimes:
		return option.Some[Expr](&MathPrimes{SyntaxNode: node})
	case SyntaxKindMathFrac:
		return option.Some[Expr](&MathFrac{SyntaxNode: node})
	case SyntaxKindMathRoot:
		return option.Some[Expr](&MathRoot{SyntaxNode: node})
	case SyntaxKindIdent:
		return option.Some[Expr](&Ident{SyntaxNode: node})
	case SyntaxKindNone:
		return option.Some[Expr](&None{SyntaxNode: node})
	case SyntaxKindAuto:
		return option.Some[Expr](&Auto{SyntaxNode: node})
	case SyntaxKindBool:
		return option.Some[Expr](&Bool{SyntaxNode: node})
	case SyntaxKindInt:
		return option.Some[Expr](&Int{SyntaxNode: node})
	case SyntaxKindFloat:
		return option.Some[Expr](&Float{SyntaxNode: node})
	case SyntaxKindNumeric:
		return option.Some[Expr](&Numeric{SyntaxNode: node})
	case SyntaxKindStr:
		return option.Some[Expr](&Str{SyntaxNode: node})
	case SyntaxKindCodeBlock:
		return option.Some[Expr](&CodeBlock{SyntaxNode: node})
	case SyntaxKindContentBlock:
		return option.Some[Expr](&ContentBlock{SyntaxNode: node})
	case SyntaxKindParenthesized:
		return option.Some[Expr](&Parenthesized{SyntaxNode: node})
	case SyntaxKindArray:
		return option.Some[Expr](&Array{SyntaxNode: node})
	case SyntaxKindDict:
		return option.Some[Expr](&Dict{SyntaxNode: node})
	case SyntaxKindUnary:
		return option.Some[Expr](&Unary{SyntaxNode: node})
	case SyntaxKindBinary:
		return option.Some[Expr](&Binary{SyntaxNode: node})
	case SyntaxKindFieldAccess:
		return option.Some[Expr](&FieldAccess{SyntaxNode: node})
	case SyntaxKindFuncCall:
		return option.Some[Expr](&FuncCall{SyntaxNode: node})
	case SyntaxKindClosure:
		return option.Some[Expr](&Closure{SyntaxNode: node})
	case SyntaxKindLetBinding:
		return option.Some[Expr](&LetBinding{SyntaxNode: node})
	case SyntaxKindDestructAssignment:
		return option.Some[Expr](&DestructAssignment{SyntaxNode: node})
	case SyntaxKindSetRule:
		return option.Some[Expr](&SetRule{SyntaxNode: node})
	case SyntaxKindShowRule:
		return option.Some[Expr](&ShowRule{SyntaxNode: node})
	case SyntaxKindContextual:
		return option.Some[Expr](&Contextual{SyntaxNode: node})
	case SyntaxKindConditional:
		return option.Some[Expr](&Conditional{SyntaxNode: node})
	case SyntaxKindWhileLoop:
		return option.Some[Expr](&WhileLoop{SyntaxNode: node})
	case SyntaxKindForLoop:
		return option.Some[Expr](&ForLoop{SyntaxNode: node})
	case SyntaxKindModuleImport:
		return option.Some[Expr](&ModuleImport{SyntaxNode: node})
	case SyntaxKindModuleInclude:
		return option.Some[Expr](&ModuleInclude{SyntaxNode: node})
	case SyntaxKindLoopBreak:
		return option.Some[Expr](&LoopBreak{SyntaxNode: node})
	case SyntaxKindLoopContinue:
		return option.Some[Expr](&LoopContinue{SyntaxNode: node})
	case SyntaxKindFuncReturn:
		return option.Some[Expr](&FuncReturn{SyntaxNode: node})
	default:
		return option.None[Expr]()
	}
}

// Can this expression be embedded into markup with a hash?
//
// hash
func Expr_hash(expr Expr) bool {
	switch expr.(type) {
	case *Ident:
		return true
	case *None:
		return true
	case *Auto:
		return true
	case *Bool:
		return true
	case *Int:
		return true
	case *Float:
		return true
	case *Numeric:
		return true
	case *Str:
		return true
	case *CodeBlock:
		return true
	case *ContentBlock:
		return true
	case *Array:
		return true
	case *Dict:
		return true
	case *Parenthesized:
		return true
	case *FieldAccess:
		return true
	case *FuncCall:
		return true
	case *LetBinding:
		return true
	case *SetRule:
		return true
	case *ShowRule:
		return true
	case *Contextual:
		return true
	case *Conditional:
		return true
	case *WhileLoop:
		return true
	case *ForLoop:
		return true
	case *ModuleImport:
		return true
	case *ModuleInclude:
		return true
	case *LoopBreak:
		return true
	case *LoopContinue:
		return true
	case *FuncReturn:
		return true
	}
	return false
}

// Is this a literal?
//
// is_literal
func Expr_is_literal(expr Expr) bool {
	switch expr.(type) {
	case *None:
		return true
	case *Auto:
		return true
	case *Bool:
		return true
	case *Int:
		return true
	case *Float:
		return true
	case *Numeric:
		return true
	case *Str:
		return true
	}
	return false
}

// default
func Expr_default() Expr {
	return None_default()
}

// --- [ Text ] ----------------------------------------------------------------

// Plain text without markup.
type Text struct {
	*SyntaxNode
}

// Get the text.
func (node *Text) get() string {
	return node.SyntaxNode.text()
}

// --- [ Space ] ---------------------------------------------------------------

// Whitespace in markup or math. Has at most one newline in markup, as more
// indicate a paragraph break.
type Space struct {
	*SyntaxNode
}

// --- [ Linebreak ] -----------------------------------------------------------

// A forced line break: `\`.
type Linebreak struct {
	*SyntaxNode
}

// --- [ Parbreak ] ------------------------------------------------------------

// A paragraph break, indicated by one or multiple blank lines.
type Parbreak struct {
	*SyntaxNode
}

// --- [ Escape ] --------------------------------------------------------------

// An escape sequence: `\#`, `\u{1F5FA}`.
type Escape struct {
	*SyntaxNode
}

// Get the escaped character.
func (node *Escape) get() rune {
	s := scanner.New(node.SyntaxNode.text())
	s.Expect("\\")
	if s.EatIf("u{") {
		hex := s.EatWhileFunc(stdx.IsAsciiHexdigit)
		x, err := strconv.ParseUint(hex, 16, 32)
		if err != nil {
			return 0 // default value.
		}
		r := rune(x)
		// TODO: handle invalid rune and return default value (i.e. 0)?
		return r
	} else {
		if c, ok := s.Eat(); ok {
			return c
		}
		return 0 // default value.
	}
}

// --- [ Shorthand ] -----------------------------------------------------------

// A shorthand for a unicode codepoint. For example, `~` for a non-breaking
// space or `-?` for a soft hyphen.
type Shorthand struct {
	*SyntaxNode
}

// A list of all shorthands in markup mode.
//
// LIST
var Shorthand_LIST = map[string]rune{
	"...": '…',
	"~":   '\u00A0',
	"-":   '\u2212', // Only before a digit
	"--":  '\u2013',
	"---": '\u2014',
	"-?":  '\u00AD',
}

// Get the shorthanded character.
func (node *Shorthand) get() rune {
	text := node.SyntaxNode.text()
	return Shorthand_LIST[text]
}

// --- [ SmartQuote ] ----------------------------------------------------------

// A smart quote: `'` or `"`.
type SmartQuote struct {
	*SyntaxNode
}

// Whether this is a double quote.
func (node *SmartQuote) double() bool {
	return node.SyntaxNode.text() == "\""
}

// --- [ Strong ] --------------------------------------------------------------

// Strong content: `*Strong*`.
type Strong struct {
	*SyntaxNode
}

// The contents of the strong node.
func (node *Strong) body() *Markup {
	return SyntaxNode_cast_first[*Markup](node.SyntaxNode)
}

// --- [ Emph ] ----------------------------------------------------------------

// Emphasized content: `_Emphasized_`.
type Emph struct {
	*SyntaxNode
}

// The contents of the emphasis node.
func (node *Emph) body() *Markup {
	return SyntaxNode_cast_first[*Markup](node.SyntaxNode)
}

// --- [ Raw ] -----------------------------------------------------------------

// Raw text with optional syntax highlighting: “ `...` “.
type Raw struct {
	*SyntaxNode
}

// The lines in the raw block.
func (node *Raw) lines() []*Text {
	var text_nodes []*Text
	for _, child := range node.children() {
		if text_node, ok := SyntaxNode_cast[*Text](child).Get(); ok {
			text_nodes = append(text_nodes, text_node)
		}
	}
	return text_nodes
}

// An optional identifier specifying the language to syntax-highlight in.
func (node *Raw) lang() option.Option[*RawLang] {
	// Only blocky literals are supposed to contain a language.
	delim, ok := SyntaxNode_try_cast_first[*RawDelim](node.SyntaxNode).Get()
	if !ok {
		return option.None[*RawLang]()
	}
	if delim.SyntaxNode.len() < 3 {
		return option.None[*RawLang]()
	}
	return SyntaxNode_try_cast_first[*RawLang](node.SyntaxNode)
}

// Whether the raw text should be displayed in a separate block.
func (node *Raw) block() bool {
	delim, ok := SyntaxNode_try_cast_first[*RawDelim](node.SyntaxNode).Get()
	if !ok {
		return false
	}
	if delim.SyntaxNode.len() < 3 {
		return false
	}
	for _, child := range node.SyntaxNode.children() {
		if child.kind() == SyntaxKindRawTrimmed && strings.ContainsFunc(child.text(), isNewline) {
			return true
		}
	}
	return false
}

// --- [ RawLang ] -------------------------------------------------------------

// A language tag at the start of raw element: “typ “.
type RawLang struct {
	*SyntaxNode
}

// Get the language tag.
func (node *RawLang) get() string {
	return node.SyntaxNode.text()
}

// --- [ RawDelim ] ------------------------------------------------------------

// A raw delimiter in single or 3+ backticks: “ ` “.
type RawDelim struct {
	*SyntaxNode
}

// --- [ Link ] ----------------------------------------------------------------

// A hyperlink: `https://typst.org`.
type Link struct {
	*SyntaxNode
}

// Get the URL.
func (node *Link) get() string {
	return node.SyntaxNode.text()
}

// --- [ Label ] ---------------------------------------------------------------

// A label: `<intro>`.
type Label struct {
	*SyntaxNode
}

// Get the label's text.
func (node *Label) get() string {
	text := node.SyntaxNode.text()
	text = strings.TrimPrefix(text, "<")
	text = strings.TrimSuffix(text, ">")
	return text
}

// --- [ Ref ] -----------------------------------------------------------------

// A reference: `@target`, `@target[..]`.
type Ref struct {
	*SyntaxNode
}

// Get the target.
//
// Will not be empty.
func (node *Ref) target() string {
	for _, child := range node.SyntaxNode.children() {
		if child.kind() == SyntaxKindRefMarker {
			text := child.text()
			return strings.TrimPrefix(text, "@")
		}
	}
	panic("unreachable") // will not be empty
}

// Get the supplement.
func (node *Ref) supplement() option.Option[*ContentBlock] {
	return SyntaxNode_try_cast_last[*ContentBlock](node.SyntaxNode)
}

// --- [ Heading ] -------------------------------------------------------------

// A section heading: `= Introduction`.
type Heading struct {
	*SyntaxNode
}

// The contents of the heading.
func (node *Heading) body() *Markup {
	return SyntaxNode_cast_first[*Markup](node.SyntaxNode)
}

// The section depth (number of equals signs).
//
// NonZeroUsize
func (node *Heading) depth() uint64 {
	for _, child := range node.children() {
		if child.kind() == SyntaxKindHeadingMarker {
			n := child.len()
			if n < 1 {
				panic(fmt.Sprintf("expected > 0 heading depth, got %d", n))
			}
			return uint64(n)
		}
	}
	return 1 // default value.
}

// --- [ ListItem ] ------------------------------------------------------------

// An item in a bullet list: `- ...`.
type ListItem struct {
	*SyntaxNode
}

// The contents of the list item.
func (node *ListItem) body() *Markup {
	return SyntaxNode_cast_first[*Markup](node.SyntaxNode)
}

// --- [ EnumItem ] ------------------------------------------------------------

// An item in an enumeration (numbered list): `+ ...` or `1. ...`.
type EnumItem struct {
	*SyntaxNode
}

// The explicit numbering, if any: `23.`.
func (node *EnumItem) number() option.Option[uint64] {
	for _, child := range node.children() {
		if child.kind() == SyntaxKindEnumMarker {
			str := strings.TrimSuffix(child.text(), ".")
			x, err := strconv.ParseUint(str, 10, 64)
			if err != nil {
				// TODO: report warning?
				return option.None[uint64]()
			}
			return option.Some(x)
		}
	}
	return option.None[uint64]()
}

// The contents of the list item.
func (node *EnumItem) body() *Markup {
	return SyntaxNode_cast_first[*Markup](node.SyntaxNode)
}

// --- [ TermItem ] ------------------------------------------------------------

// An item in a term list: `/ Term: Details`.
type TermItem struct {
	*SyntaxNode
}

// The term described by the item.
func (node *TermItem) term() *Markup {
	return SyntaxNode_cast_first[*Markup](node.SyntaxNode)
}

// The description of the term.
func (node *TermItem) description() *Markup {
	return SyntaxNode_cast_last[*Markup](node.SyntaxNode)
}

// --- [ Equation ] ------------------------------------------------------------

// A mathematical equation: `$x$`, `$ x^2 $`.
type Equation struct {
	*SyntaxNode
}

// The contained math.
func (node *Equation) body() *Math {
	return SyntaxNode_cast_first[*Math](node.SyntaxNode)
}

// Whether the equation should be displayed as a separate block.
func (node *Equation) block() bool {
	children := node.children()
	if len(children) < 2 {
		return false
	}
	first := children[1]                // first node inside $..$
	last := children[len(children)-1-1] // last node inside $..$
	return first.kind() == SyntaxKindSpace && last.kind() == SyntaxKindSpace
}

// --- [ Math ] ----------------------------------------------------------------

// The contents of a mathematical equation: `x^2 + 1`.
type Math struct {
	*SyntaxNode
}

// The expressions the mathematical content consists of.
func (node *Math) exprs() []Expr {
	var exprs []Expr
	for _, child := range node.children() {
		if expr, ok := Expr_cast_with_space(child).Get(); ok {
			exprs = append(exprs, expr)
		}
	}
	return exprs
}

// Whether this `Math` node was originally parenthesized.
func (node *Math) was_deparenthesized() bool {
	children := node.children()
	first := children[0]
	last := children[len(children)-1]
	return first.kind() == SyntaxKindLeftParen && last.kind() == SyntaxKindRightParen
}

// --- [ MathText ] ------------------------------------------------------------

// A lone text fragment in math: `x`, `25`, `3.1415`, `=`, `[`.
type MathText struct {
	*SyntaxNode
}

// The underlying text kind.
type MathTextKind interface {
	isMathTextKind()
}

func (*MathTextKind_Character) isMathTextKind() {}
func (*MathTextKind_Number) isMathTextKind()    {}

type MathTextKind_Character struct {
	c rune
}

type MathTextKind_Number struct {
	str string
}

// Return the underlying text.
func (node *MathText) get() MathTextKind {
	text := node.SyntaxNode.text()
	chars := []rune(text)
	c := chars[0]
	if stdx.IsNumeric(c) {
		// Numbers are potentially grouped as multiple characters. This is
		// done in `Lexer::math_text()`.
		return &MathTextKind_Number{
			str: text,
		}
	} else {
		if len(chars) > 1 {
			panic(fmt.Sprintf("expected a single character in math text, got %d", len(chars)))
		}
		return &MathTextKind_Character{
			c: c,
		}
	}
}

// --- [ MathIdent ] -----------------------------------------------------------

// An identifier in math: `pi`.
type MathIdent struct {
	*SyntaxNode
}

// Get the identifier.
//
// as_str
// deref
func (node *MathIdent) get() string {
	return node.SyntaxNode.text()
}

// --- [ MathShorthand ] -------------------------------------------------------

// A shorthand for a unicode codepoint in math: `a <= b`.
type MathShorthand struct {
	*SyntaxNode
}

// A list of all shorthands in math mode.
var MathShorthand_LIST = map[string]rune{
	"...":  '…',
	"-":    '−',
	"*":    '∗',
	"~":    '∼',
	"!=":   '≠',
	":=":   '≔',
	"::=":  '⩴',
	"=:":   '≕',
	"<<":   '≪',
	"<<<":  '⋘',
	">>":   '≫',
	">>>":  '⋙',
	"<=":   '≤',
	">=":   '≥',
	"->":   '→',
	"-->":  '⟶',
	"|->":  '↦',
	">->":  '↣',
	"->>":  '↠',
	"<-":   '←',
	"<--":  '⟵',
	"<-<":  '↢',
	"<<-":  '↞',
	"<->":  '↔',
	"<-->": '⟷',
	"~>":   '⇝',
	"~~>":  '⟿',
	"<~":   '⇜',
	"<~~":  '⬳',
	"=>":   '⇒',
	"|=>":  '⤇',
	"==>":  '⟹',
	"<==":  '⟸',
	"<=>":  '⇔',
	"<==>": '⟺',
	"[|":   '⟦',
	"|]":   '⟧',
	"||":   '‖',
}

// Get the shorthanded character.
func (node *MathShorthand) get() rune {
	text := node.SyntaxNode.text()
	return MathShorthand_LIST[text]
}

// --- [ MathAlignPoint ] ------------------------------------------------------

// An alignment point in math: `&`.
type MathAlignPoint struct {
	*SyntaxNode
}

// --- [ MathDelimited ] -------------------------------------------------------

// Matched delimiters in math: `[x + y]`.
type MathDelimited struct {
	*SyntaxNode
}

// The opening delimiter.
func (node *MathDelimited) open() Expr {
	return SyntaxNode_cast_first[Expr](node.SyntaxNode)
}

// The contents, including the delimiters.
func (node *MathDelimited) body() *Math {
	return SyntaxNode_cast_first[*Math](node.SyntaxNode)
}

// The closing delimiter.
func (node *MathDelimited) close() Expr {
	return SyntaxNode_cast_last[Expr](node.SyntaxNode)
}

// --- [ MathAttach ] ----------------------------------------------------------

// A base with optional attachments in math: `a_1^2`.
type MathAttach struct {
	*SyntaxNode
}

// The base, to which things are attached.
func (node *MathAttach) base() Expr {
	return SyntaxNode_cast_first[Expr](node.SyntaxNode)
}

// The bottom attachment.
func (node *MathAttach) bottom() option.Option[Expr] {
	found := false
	for _, child := range node.children() {
		if found {
			return SyntaxNode_cast[Expr](child)
		}
		if child.kind() == SyntaxKindUnderscore {
			found = true
		}
	}
	return option.None[Expr]()
}

// The top attachment.
func (node *MathAttach) top() option.Option[Expr] {
	found := false
	for _, child := range node.children() {
		if found {
			return SyntaxNode_cast[Expr](child)
		}
		if child.kind() == SyntaxKindHat {
			found = true
		}
	}
	return option.None[Expr]()
}

// Extract attached primes if present.
func (node *MathAttach) primes() option.Option[*MathPrimes] {
	var expr_children []*SyntaxNode
	// TODO: double-check conversion from Rust to Go.
	for _, child := range node.children() {
		_, ok := SyntaxNode_cast[Expr](child).Get()
		if ok {
			expr_children = append(expr_children, child)
		}
	}
	if len(expr_children) > 1 {
		expr_child := expr_children[1]
		return SyntaxNode_cast[*MathPrimes](expr_child)
	}
	return option.None[*MathPrimes]()
}

// --- [ MathPrimes ] ----------------------------------------------------------

// Grouped primes in math: `a”'`.
type MathPrimes struct {
	*SyntaxNode
}

// The number of grouped primes.
func (node *MathPrimes) count() uint64 {
	n := uint64(0)
	for _, child := range node.children() {
		if child.kind() == SyntaxKindPrime {
			n++
		}
	}
	return n
}

// --- [ MathFrac ] ------------------------------------------------------------

// A fraction in math: `x/2`
type MathFrac struct {
	*SyntaxNode
}

// The numerator.
func (node *MathFrac) num() Expr {
	return SyntaxNode_cast_first[Expr](node.SyntaxNode)
}

// The denominator.
func (node *MathFrac) denom() Expr {
	return SyntaxNode_cast_last[Expr](node.SyntaxNode)
}

// --- [ MathRoot ] ------------------------------------------------------------

// A root in math: `√x`, `∛x` or `∜x`.
type MathRoot struct {
	*SyntaxNode
}

// The index of the root.
func (node *MathRoot) index() option.Option[uint64] {
	for _, child := range node.children() {
		switch child.text() {
		case "∜":
			return option.Some[uint64](4)
		case "∛":
			return option.Some[uint64](3)
		case "√":
			return option.None[uint64]()
		}
	}
	return option.None[uint64]()
}

// The radicand.
func (node *MathRoot) radicand() Expr {
	return SyntaxNode_cast_first[Expr](node.SyntaxNode)
}

// --- [ Ident ] ---------------------------------------------------------------

// An identifier: `it`.
type Ident struct {
	*SyntaxNode
}

// Get the identifier.
//
// as_str
// deref
func (node *Ident) get() string {
	return node.SyntaxNode.text()
}

// --- [ None ] ----------------------------------------------------------------

// The `none` literal.
type None struct {
	*SyntaxNode
}

// --- [ Auto ] ----------------------------------------------------------------

// The `auto` literal.
type Auto struct {
	*SyntaxNode
}

// --- [ Bool ] ----------------------------------------------------------------

// A boolean: `true`, `false`.
type Bool struct {
	*SyntaxNode
}

// Get the boolean value.
func (node *Bool) get() bool {
	return node.SyntaxNode.text() == "true"
}

// --- [ Int ] -----------------------------------------------------------------

// An integer: `120`.
type Int struct {
	*SyntaxNode
}

// Get the integer value.
func (node *Int) get() int64 {
	text := node.SyntaxNode.text()
	var (
		s    string
		base int
	)
	switch {
	case strings.HasPrefix(text, "0x"):
		s = strings.TrimPrefix(text, "0x")
		base = 16
	case strings.HasPrefix(text, "0o"):
		s = strings.TrimPrefix(text, "0o")
		base = 8
	case strings.HasPrefix(text, "0b"):
		s = strings.TrimPrefix(text, "0b")
		base = 2
	default:
		base = 10
	}
	x, err := strconv.ParseInt(s, base, 64)
	if err != nil {
		// TODO: report warning?
		return 0 // default
	}
	return x
}

// --- [ Float ] ---------------------------------------------------------------

// A floating-point number: `1.2`, `10e-4`.
type Float struct {
	*SyntaxNode
}

// Get the floating-point value.
func (node *Float) get() float64 {
	text := node.SyntaxNode.text()
	x, err := strconv.ParseFloat(text, 64)
	if err != nil {
		// TODO: report warning?
		return 0.0 // default
	}
	return x
}

// --- [ Numeric ] -------------------------------------------------------------

// A numeric value with a unit: `12pt`, `3cm`, `2em`, `90deg`, `50%`.
type Numeric struct {
	*SyntaxNode
}

// Get the numeric value and unit.
func (node *Numeric) get() (float64, Unit) {
	text := node.SyntaxNode.text()
	chars := []rune(text)
	count := 0
	for _, c := range slices.Backward(chars) {
		if stdx.IsAsciiLowercase(c) || c == '%' {
			count++
		}
	}
	split := len(text) - count
	value_str := text[:split]
	unit_str := text[split:]
	value, err := strconv.ParseFloat(value_str, 64)
	if err != nil {
		// TODO: report warning?
		value = 0.0 // default
	}
	var unit Unit
	switch unit_str {
	case "pt":
		unit = Unit_Pt
	case "mm":
		unit = Unit_Mm
	case "cm":
		unit = Unit_Cm
	case "in":
		unit = Unit_In
	case "deg":
		unit = Unit_Deg
	case "rad":
		unit = Unit_Rad
	case "em":
		unit = Unit_Em
	case "fr":
		unit = Unit_Fr
	case "%":
		unit = Unit_Percent
	default:
		unit = Unit_Percent
	}

	return value, unit
}

// Unit of a numeric value.
type Unit uint8

const (
	// Points.
	//
	// Pt
	Unit_Pt Unit = iota + 1
	// Millimeters.
	//
	// Mm
	Unit_Mm
	// Centimeters.
	//
	// Cm
	Unit_Cm
	// Inches.
	//
	// In
	Unit_In
	// Radians.
	//
	// Rad
	Unit_Rad
	// Degrees.
	//
	// Deg
	Unit_Deg
	// Font-relative: `1em` is the same as the font size.
	//
	// Em
	Unit_Em
	// Fractions: `fr`.
	//
	// Fr
	Unit_Fr
	// Percentage: `%`.
	//
	// Percent
	Unit_Percent
)

// --- [ Str ] -----------------------------------------------------------------

// A quoted string: `"..."`.
type Str struct {
	*SyntaxNode
}

// Get the string value with resolved escape sequences.
func (node *Str) get() string {
	text := node.SyntaxNode.text()
	unquoted := text[1 : len(text)-1]
	if !strings.ContainsRune(unquoted, '\\') {
		return unquoted
	}

	out := &strings.Builder{}
	out.Grow(len(unquoted))
	s := scanner.New(unquoted)

	for {
		c, ok := s.Eat()
		if !ok {
			break
		}
		if c != '\\' {
			out.WriteRune(c)
			continue
		}

		start := s.Locate(-1)
		c, ok = s.Eat()
		if !ok {
			out.WriteString(s.From(start))
			continue
		}
		switch {
		case c == '\\':
			out.WriteRune('\\')
		case c == '"':
			out.WriteRune('"')
		case c == 'n':
			out.WriteRune('\n')
		case c == 'r':
			out.WriteRune('\r')
		case c == 't':
			out.WriteRune('\t')
		case c == 'u' && s.EatIf("{"):
			sequence := s.EatWhileFunc(stdx.IsAsciiHexdigit)
			s.EatIf("}")
			x, err := strconv.ParseUint(sequence, 16, 32)
			if err != nil {
				// TODO: report warning?
				out.WriteString(s.From(start))
				continue
			}
			r := rune(x) // TODO: handle invalid rune (using `out.WriteString(s.From(start))`)?
			out.WriteRune(r)
		default:
			out.WriteString(s.From(start))
		}
	}

	return out.String()
}

// --- [ CodeBlock ] -----------------------------------------------------------

// A code block: `{ let x = 1; x + 2 }`.
type CodeBlock struct {
	*SyntaxNode
}

// The contained code.
func (node *CodeBlock) body() *Code {
	return SyntaxNode_cast_first[*Code](node.SyntaxNode)
}

// --- [ Code ] ----------------------------------------------------------------

// The body of a code block.
type Code struct {
	*SyntaxNode
}

// The list of expressions contained in the code.
func (node *Code) exprs() []Expr {
	var exprs []Expr
	for _, child := range node.children() {
		if expr, ok := SyntaxNode_cast[Expr](child).Get(); ok {
			exprs = append(exprs, expr)
		}
	}
	return exprs
}

// --- [ ContentBlock ] --------------------------------------------------------

// A content block: `[*Hi* there!]`.
type ContentBlock struct {
	*SyntaxNode
}

// The contained markup.
func (node *ContentBlock) body() *Markup {
	return SyntaxNode_cast_first[*Markup](node.SyntaxNode)
}

// --- [ Parenthesized ] -------------------------------------------------------

// A grouped expression: `(1 + 2)`.
type Parenthesized struct {
	*SyntaxNode
}

// The wrapped expression.
//
// Should only be accessed if this is contained in an `Expr`.
func (node *Parenthesized) expr() Expr {
	return SyntaxNode_cast_first[Expr](node.SyntaxNode)
}

// The wrapped pattern.
//
// Should only be accessed if this is contained in a `Pattern`.
func (node *Parenthesized) pattern() Pattern {
	return SyntaxNode_cast_first[Pattern](node.SyntaxNode)
}

// --- [ Array ] ---------------------------------------------------------------

// An array: `(1, "hi", 12cm)`.
type Array struct {
	*SyntaxNode
}

// The array's items.
func (node *Array) items() []ArrayItem {
	var items []ArrayItem
	for _, child := range node.children() {
		if item, ok := SyntaxNode_cast[ArrayItem](child).Get(); ok {
			items = append(items, item)
		}
	}
	return items
}

// An item in an array.
type ArrayItem interface {
	AstNode

	isArrayItem()
}

func (*ArrayItem_Pos) isArrayItem()    {}
func (*ArrayItem_Spread) isArrayItem() {}

// A bare expression: `12`.
//
// Pos
type ArrayItem_Pos struct {
	expr Expr
}

// A spread expression: `..things`.
//
// Spread
type ArrayItem_Spread struct {
	spread *Spread
}

// --- [ Dict ] ----------------------------------------------------------------

// A dictionary: `(thickness: 3pt, dash: "solid")`.
type Dict struct {
	*SyntaxNode
}

// The dictionary's items.
func (node *Dict) items() []DictItem {
	var items []DictItem
	for _, child := range node.children() {
		if item, ok := SyntaxNode_cast[DictItem](child).Get(); ok {
			items = append(items, item)
		}
	}
	return items
}

// An item in an dictionary expression.
type DictItem interface {
	AstNode

	isDictItem()
}

// A named pair: `thickness: 3pt`.
//
// Named
type DictItem_Named struct {
	item *Named
}

// A keyed pair: `"spacy key": true`.
//
// Keyed
type DictItem_Keyed struct {
	item *Keyed
}

// A spread expression: `..things`.
//
// Spread
type DictItem_Spread struct {
	item *Spread
}

// --- [ Named ] ---------------------------------------------------------------

// A named pair: `thickness: 3pt`.
type Named struct {
	*SyntaxNode
}

// The name: `thickness`.
func (node *Named) name() *Ident {
	return SyntaxNode_cast_first[*Ident](node.SyntaxNode)
}

// The right-hand side of the pair: `3pt`.
//
// This should only be accessed if this `Named` is contained in a
// `DictItem`, `Arg`, or `Param`.
func (node *Named) expr() Expr {
	return SyntaxNode_cast_last[Expr](node.SyntaxNode)
}

// The right-hand side of the pair as a pattern.
//
// This should only be accessed if this `Named` is contained in a
// `Destructuring`.
func (node *Named) pattern() Pattern {
	return SyntaxNode_cast_last[Pattern](node.SyntaxNode)
}

// --- [ Keyed ] ---------------------------------------------------------------

// A keyed pair: `"spacy key": true`.
type Keyed struct {
	*SyntaxNode
}

// The key: `"spacy key"`.
func (node *Keyed) key() Expr {
	return SyntaxNode_cast_first[Expr](node.SyntaxNode)
}

// The right-hand side of the pair: `true`.
//
// This should only be accessed if this `Keyed` is contained in a
// `DictItem`.
func (node *Keyed) expr() Expr {
	return SyntaxNode_cast_last[Expr](node.SyntaxNode)
}

// --- [ Spread ] --------------------------------------------------------------

// A spread: `..x` or `..x.at(0)`.
type Spread struct {
	*SyntaxNode
}

// The spread expression.
//
// This should only be accessed if this `Spread` is contained in an
// `ArrayItem`, `DictItem`, or `Arg`.
func (node *Spread) expr() Expr {
	return SyntaxNode_cast_first[Expr](node.SyntaxNode)
}

// The sink identifier, if present.
//
// This should only be accessed if this `Spread` is contained in a
// `Param` or binding `DestructuringItem`.
func (node *Spread) sink_ident() option.Option[*Ident] {
	return SyntaxNode_try_cast_first[*Ident](node.SyntaxNode)
}

// The sink expressions, if present.
//
// This should only be accessed if this `Spread` is contained in a
// `DestructuringItem`.
func (node *Spread) sink_expr() option.Option[Expr] {
	return SyntaxNode_try_cast_first[Expr](node.SyntaxNode)
}

// --- [ Unary ] ---------------------------------------------------------------

// A unary operation: `-x`.
type Unary struct {
	*SyntaxNode
}

// The operator: `-`.
func (node *Unary) op() UnOp {
	for _, child := range node.children() {
		if op, ok := UnOp_from_kind(child.kind()).Get(); ok {
			return op
		}
	}
	return UnOp_Pos
}

// The expression to operate on: `x`.
func (node *Unary) expr() Expr {
	return SyntaxNode_cast_last[Expr](node.SyntaxNode)
}

// A unary operator.
type UnOp uint8

const (
	// The plus operator: `+`.
	//
	// Pos
	UnOp_Pos UnOp = iota + 1
	// The negation operator: `-`.
	//
	// Neg
	UnOp_Neg
	// The boolean `not`.
	//
	// Not
	UnOp_Not
)

// Try to convert the token into a unary operation.
func UnOp_from_kind(token SyntaxKind) option.Option[UnOp] {
	switch token {
	case SyntaxKindPlus:
		return option.Some(UnOp_Pos)
	case SyntaxKindMinus:
		return option.Some(UnOp_Neg)
	case SyntaxKindNot:
		return option.Some(UnOp_Not)
	}
	return option.None[UnOp]()
}

// The precedence of this operator.
func (op UnOp) precedence() uint {
	switch op {
	case UnOp_Pos, UnOp_Neg:
		return 7
	case UnOp_Not:
		return 4
	}
	panic("unreachable")
}

// The string representation of this operation.
//
// as_str
func (op UnOp) String() string {
	switch op {
	case UnOp_Pos:
		return "+"
	case UnOp_Neg:
		return "-"
	case UnOp_Not:
		return "not"
	}
	panic("unreachable")
}

// --- [ Binary ] --------------------------------------------------------------

// A binary operation: `a + b`.
type Binary struct {
	*SyntaxNode
}

// The binary operator: `+`.
func (node *Binary) op() BinOp {
	not := false
	for _, child := range node.children() {
		switch node.kind() {
		case SyntaxKindNot:
			not = true
			continue
		case SyntaxKindIn:
			if not {
				return BinOp_NotIn
			}
		}
		if op, ok := BinOp_from_kind(child.kind()).Get(); ok {
			return op
		}
	}
	return BinOp_Add
}

// The left-hand side of the operation: `a`.
func (node *Binary) lhs() Expr {
	return SyntaxNode_cast_first[Expr](node.SyntaxNode)
}

// The right-hand side of the operation: `b`.
func (node *Binary) rhs() Expr {
	return SyntaxNode_cast_last[Expr](node.SyntaxNode)
}

// A binary operator.
type BinOp uint8

const (
	// The addition operator: `+`.
	//
	// Add
	BinOp_Add BinOp = iota + 1
	// The subtraction operator: `-`.
	//
	// Sub
	BinOp_Sub
	// The multiplication operator: `*`.
	//
	// Mul
	BinOp_Mul
	// The division operator: `/`.
	//
	// Div
	BinOp_Div
	// The short-circuiting boolean `and`.
	//
	// And
	BinOp_And
	// The short-circuiting boolean `or`.
	//
	// Or
	BinOp_Or
	// The equality operator: `==`.
	//
	// Eq
	BinOp_Eq
	// The inequality operator: `!=`.
	//
	// Neq
	BinOp_Neq
	// The less-than operator: `<`.
	//
	// Lt
	BinOp_Lt
	// The less-than or equal operator: `<=`.
	//
	// Leq
	BinOp_Leq
	// The greater-than operator: `>`.
	//
	// Gt
	BinOp_Gt
	// The greater-than or equal operator: `>=`.
	//
	// Geq
	BinOp_Geq
	// The assignment operator: `=`.
	//
	// Assign
	BinOp_Assign
	// The containment operator: `in`.
	//
	// In
	BinOp_In
	// The inverse containment operator: `not in`.
	//
	// NotIn
	BinOp_NotIn
	// The add-assign operator: `+=`.
	//
	// AddAssign
	BinOp_AddAssign
	// The subtract-assign operator: `-=`.
	//
	// SubAssign
	BinOp_SubAssign
	// The multiply-assign operator: `*=`.
	//
	// MulAssign
	BinOp_MulAssign
	// The divide-assign operator: `/=`.
	//
	// DivAssign
	BinOp_DivAssign
)

// Try to convert the token into a binary operation.
//
// from_kind
func BinOp_from_kind(token SyntaxKind) option.Option[BinOp] {
	switch token {
	case SyntaxKindPlus:
		return option.Some(BinOp_Add)
	case SyntaxKindMinus:
		return option.Some(BinOp_Sub)
	case SyntaxKindStar:
		return option.Some(BinOp_Mul)
	case SyntaxKindSlash:
		return option.Some(BinOp_Div)
	case SyntaxKindAnd:
		return option.Some(BinOp_And)
	case SyntaxKindOr:
		return option.Some(BinOp_Or)
	case SyntaxKindEqEq:
		return option.Some(BinOp_Eq)
	case SyntaxKindExclEq:
		return option.Some(BinOp_Neq)
	case SyntaxKindLt:
		return option.Some(BinOp_Lt)
	case SyntaxKindLtEq:
		return option.Some(BinOp_Leq)
	case SyntaxKindGt:
		return option.Some(BinOp_Gt)
	case SyntaxKindGtEq:
		return option.Some(BinOp_Geq)
	case SyntaxKindEq:
		return option.Some(BinOp_Assign)
	case SyntaxKindIn:
		return option.Some(BinOp_In)
	case SyntaxKindPlusEq:
		return option.Some(BinOp_AddAssign)
	case SyntaxKindHyphEq:
		return option.Some(BinOp_SubAssign)
	case SyntaxKindStarEq:
		return option.Some(BinOp_MulAssign)
	case SyntaxKindSlashEq:
		return option.Some(BinOp_DivAssign)
	}
	return option.None[BinOp]()
}

// The precedence of this operator.
func (op BinOp) precedence() uint {
	switch op {
	case BinOp_Mul:
		return 6
	case BinOp_Div:
		return 6
	case BinOp_Add:
		return 5
	case BinOp_Sub:
		return 5
	case BinOp_Eq:
		return 4
	case BinOp_Neq:
		return 4
	case BinOp_Lt:
		return 4
	case BinOp_Leq:
		return 4
	case BinOp_Gt:
		return 4
	case BinOp_Geq:
		return 4
	case BinOp_In:
		return 4
	case BinOp_NotIn:
		return 4
	case BinOp_And:
		return 3
	case BinOp_Or:
		return 2
	case BinOp_Assign:
		return 1
	case BinOp_AddAssign:
		return 1
	case BinOp_SubAssign:
		return 1
	case BinOp_MulAssign:
		return 1
	case BinOp_DivAssign:
		return 1
	}
	panic("unreachable")
}

// The associativity of this operator.
func (op BinOp) assoc() Assoc {
	switch op {
	case BinOp_Add:
		return Assoc_Left
	case BinOp_Sub:
		return Assoc_Left
	case BinOp_Mul:
		return Assoc_Left
	case BinOp_Div:
		return Assoc_Left
	case BinOp_And:
		return Assoc_Left
	case BinOp_Or:
		return Assoc_Left
	case BinOp_Eq:
		return Assoc_Left
	case BinOp_Neq:
		return Assoc_Left
	case BinOp_Lt:
		return Assoc_Left
	case BinOp_Leq:
		return Assoc_Left
	case BinOp_Gt:
		return Assoc_Left
	case BinOp_Geq:
		return Assoc_Left
	case BinOp_In:
		return Assoc_Left
	case BinOp_NotIn:
		return Assoc_Left
	case BinOp_Assign:
		return Assoc_Right
	case BinOp_AddAssign:
		return Assoc_Right
	case BinOp_SubAssign:
		return Assoc_Right
	case BinOp_MulAssign:
		return Assoc_Right
	case BinOp_DivAssign:
		return Assoc_Right
	}
	panic("unreachable")
}

// The string representation of this operation.
//
// as_str
func (op BinOp) String() string {
	switch op {
	case BinOp_Add:
		return "+"
	case BinOp_Sub:
		return "-"
	case BinOp_Mul:
		return "*"
	case BinOp_Div:
		return "/"
	case BinOp_And:
		return "and"
	case BinOp_Or:
		return "or"
	case BinOp_Eq:
		return "=="
	case BinOp_Neq:
		return "!="
	case BinOp_Lt:
		return "<"
	case BinOp_Leq:
		return "<="
	case BinOp_Gt:
		return ">"
	case BinOp_Geq:
		return ">="
	case BinOp_In:
		return "in"
	case BinOp_NotIn:
		return "not in"
	case BinOp_Assign:
		return "="
	case BinOp_AddAssign:
		return "+="
	case BinOp_SubAssign:
		return "-="
	case BinOp_MulAssign:
		return "*="
	case BinOp_DivAssign:
		return "/="
	}
	panic("unreachable")
}

// The associativity of a binary operator.
type Assoc uint8

const (
	// Left-associative: `a + b + c` is equivalent to `(a + b) + c`.
	//
	// Left
	Assoc_Left Assoc = iota + 1
	// Right-associative: `a = b = c` is equivalent to `a = (b = c)`.
	//
	// Right
	Assoc_Right
)

// --- [ FieldAccess ] ---------------------------------------------------------

// A field access: `properties.age`.
type FieldAccess struct {
	*SyntaxNode
}

// The expression to access the field on.
func (node *FieldAccess) target() Expr {
	return SyntaxNode_cast_first[Expr](node.SyntaxNode)
}

// The name of the field.
func (node *FieldAccess) field() *Ident {
	return SyntaxNode_cast_last[*Ident](node.SyntaxNode)
}

// --- [ FuncCall ] ------------------------------------------------------------

// An invocation of a function or method: `f(x, y)`.
type FuncCall struct {
	*SyntaxNode
}

// The function to call.
func (node *FuncCall) callee() Expr {
	return SyntaxNode_cast_first[Expr](node.SyntaxNode)
}

// The arguments to the function.
func (node *FuncCall) args() *Args {
	return SyntaxNode_cast_last[*Args](node.SyntaxNode)
}

// --- [ Args ] ----------------------------------------------------------------

// A function call's argument list: `(12pt, y)`.
type Args struct {
	*SyntaxNode
}

// The positional and named arguments.
func (node *Args) items() []Arg {
	var args []Arg
	for _, child := range node.children() {
		if arg, ok := SyntaxNode_cast[Arg](child).Get(); ok {
			args = append(args, arg)
		}
	}
	return args
}

// Whether there is a comma at the end.
func (node *Args) trailing_comma() bool {
	children := node.children()
	for i, child := range slices.Backward(children) {
		if i == 0 {
			continue // skip first
		}
		kind := child.kind()
		// TODO: double-check that conversion from Rust to Go is correct.
		if kind.IsTrivia() {
			continue
		}
		if kind == SyntaxKindComma {
			return true
		}
	}
	return false
}

// An argument to a function call.
type Arg interface {
	AstNode

	isArg()
}

// A positional argument: `12`.
//
// Pos
type Arg_Pos struct {
	arg Expr
}

// A named argument: `draw: false`.
//
// Named
type Arg_Named struct {
	arg *Named
}

// A spread argument: `..things`.
//
// Spread
type Arg_Spread struct {
	arg *Spread
}

// --- [ Closure ] -------------------------------------------------------------

// A closure: `(x, y) => z`.
type Closure struct {
	*SyntaxNode
}

// The name of the closure.
//
// This only exists if you use the function syntax sugar: `let f(x) = y`.
func (node *Closure) name() option.Option[*Ident] {
	for _, child := range node.children() {
		return SyntaxNode_cast[*Ident](child)
	}
	return option.None[*Ident]()
}

// The parameter bindings.
func (node *Closure) params() *Params {
	return SyntaxNode_cast_first[*Params](node.SyntaxNode)
}

// The body of the closure.
func (node *Closure) body() Expr {
	return SyntaxNode_cast_last[Expr](node.SyntaxNode)
}

// --- [ Params ] --------------------------------------------------------------

// A closure's parameters: `(x, y)`.
type Params struct {
	*SyntaxNode
}

// The parameter bindings.
func (node *Params) children() []Param {
	var params []Param
	for _, child := range node.SyntaxNode.children() {
		if param, ok := SyntaxNode_cast[Param](child).Get(); ok {
			params = append(params, param)
		}
	}
	return params
}

// A parameter to a closure.
type Param interface {
	AstNode

	isParam()
}

// A positional parameter: `x`.
//
// Pos
type Param_Pos struct {
	param Pattern
}

// A named parameter with a default value: `draw: false`.
//
// Named
type Param_Named struct {
	param *Named
}

// An argument sink: `..args` or `..`.
//
// Spread
type Param_Spread struct {
	param *Spread
}

// The kind of a pattern.
type Pattern interface {
	AstNode

	isPattern()

	// Returns a list of all new bindings introduced by the pattern.
	bindings() []*Ident
}

func (*Pattern_Normal) isPattern()        {}
func (*Pattern_Placeholder) isPattern()   {}
func (*Pattern_Parenthesized) isPattern() {}
func (*Pattern_Destructuring) isPattern() {}

// A single expression: `x`.
//
// Normal
type Pattern_Normal struct {
	expr Expr
}

// A placeholder: `_`.
//
// Placeholder
type Pattern_Placeholder struct {
	pattern *Underscore
}

// A parenthesized pattern.
//
// Parenthesized
type Pattern_Parenthesized struct {
	pattern *Parenthesized
}

// A destructuring pattern: `(x, _, ..y)`.
//
// Destructuring
type Pattern_Destructuring struct {
	pattern *Destructuring
}

// --- [ Underscore ] ----------------------------------------------------------

// An underscore: `_`
type Underscore struct {
	*SyntaxNode
}

// --- [ Destructuring ] -------------------------------------------------------

// A destructuring pattern: `x` or `(x, _, ..y)`.
type Destructuring struct {
	*SyntaxNode
}

// The items of the destructuring.
func (node *Destructuring) items() []DestructuringItem {
	var items []DestructuringItem
	for _, child := range node.children() {
		if item, ok := SyntaxNode_cast[DestructuringItem](child).Get(); ok {
			items = append(items, item)
		}
	}
	return items
}

// Returns a list of all new bindings introduced by the destructuring.
func (node *Destructuring) bindings() []*Ident {
	var idents []*Ident
	for _, item := range node.items() {
		switch item := item.(type) {
		case *DestructuringItem_Pattern:
			idents = append(idents, item.pattern.bindings()...)
		case *DestructuringItem_Named:
			idents = append(idents, item.named.pattern().bindings()...)
		case *DestructuringItem_Spread:
			if ident, ok := item.spread.sink_ident().Get(); ok {
				idents = append(idents, ident)
			}
		}
	}
	return idents
}

// The kind of an element in a destructuring pattern.
type DestructuringItem interface {
	AstNode

	isDestructuringItem()
}

func (*DestructuringItem_Pattern) isDestructuringItem() {}
func (*DestructuringItem_Named) isDestructuringItem()   {}
func (*DestructuringItem_Spread) isDestructuringItem()  {}

// A sub-pattern: `x`.
//
// Pattern
type DestructuringItem_Pattern struct {
	pattern Pattern
}

// A renamed destructuring: `x: y`.
//
// Named
type DestructuringItem_Named struct {
	named *Named
}

// A destructuring sink: `..y` or `..`.
//
// Spread
type DestructuringItem_Spread struct {
	spread *Spread
}

// --- [ LetBinding ] ----------------------------------------------------------

// A let binding: `let x = 1`.
type LetBinding struct {
	*SyntaxNode
}

// The kind of a let binding, either a normal one or a closure.
type LetBindingKind interface {
	isLetBindingKind()

	// Returns a list of all new bindings introduced by the let binding.
	bindings() []*Ident
}

func (*LetBindingKind_Normal) isLetBindingKind()  {}
func (*LetBindingKind_Closure) isLetBindingKind() {}

// A normal binding: `let x = 1`.
//
// Normal
type LetBindingKind_Normal struct {
	pattern Pattern
}

// A closure binding: `let f(x) = 1`.
//
// Closure
type LetBindingKind_Closure struct {
	ident *Ident
}

// Returns a list of all new bindings introduced by the let binding.
func (let *LetBindingKind_Normal) bindings() []*Ident {
	return let.pattern.bindings()
}

// Returns a list of all new bindings introduced by the let binding.
func (let *LetBindingKind_Closure) bindings() []*Ident {
	return []*Ident{let.ident}
}

// The kind of the let binding.
func (node *LetBinding) kind() LetBindingKind {
	pattern := SyntaxNode_cast_first[Pattern](node.SyntaxNode)
	switch pattern := pattern.(type) {
	case *Pattern_Normal:
		if closure, ok := pattern.expr.(*Closure); ok {
			ident, ok := closure.name().Get()
			if !ok {
				ident = Ident_default() // default value
			}
			return &LetBindingKind_Closure{
				ident: ident,
			}
		}
	}
	return &LetBindingKind_Normal{
		pattern: pattern,
	}
}

// The expression the binding is initialized with.
func (node *LetBinding) init() option.Option[Expr] {
	let := node.kind()
	switch let := let.(type) {
	case *LetBindingKind_Normal:
		pattern := let.pattern
		switch pattern.(type) {
		case *Pattern_Normal:
			// TODO: double-check translation from Rust to Go.
			var exprs []Expr
			for _, child := range node.children() {
				if expr, ok := SyntaxNode_cast[Expr](child).Get(); ok {
					exprs = append(exprs, expr)
				}
			}
			if len(exprs) > 1 {
				return option.Some(exprs[1])
			}
		case *Pattern_Parenthesized:
			// TODO: double-check translation from Rust to Go.
			var exprs []Expr
			for _, child := range node.children() {
				if expr, ok := SyntaxNode_cast[Expr](child).Get(); ok {
					exprs = append(exprs, expr)
				}
			}
			if len(exprs) > 1 {
				return option.Some(exprs[1])
			}
		}
		return SyntaxNode_try_cast_first[Expr](node.SyntaxNode)
	case *LetBindingKind_Closure:
		return SyntaxNode_try_cast_first[Expr](node.SyntaxNode)
	}
	return option.None[Expr]()
}

// --- [ DestructAssignment ] --------------------------------------------------

// An assignment expression `(x, y) = (1, 2)`.
type DestructAssignment struct {
	*SyntaxNode
}

// The pattern of the assignment.
func (node *DestructAssignment) pattern() Pattern {
	return SyntaxNode_cast_first[Pattern](node.SyntaxNode)
}

// The expression that is assigned.
func (node *DestructAssignment) value() Expr {
	return SyntaxNode_cast_last[Expr](node.SyntaxNode)
}

// --- [ SetRule ] -------------------------------------------------------------

// A set rule: `set text(...)`.
type SetRule struct {
	*SyntaxNode
}

// The function to set style properties for.
func (node *SetRule) target() Expr {
	return SyntaxNode_cast_first[Expr](node.SyntaxNode)
}

// The style properties to set.
func (node *SetRule) args() *Args {
	return SyntaxNode_cast_last[*Args](node.SyntaxNode)
}

// A condition under which the set rule applies.
func (node *SetRule) condition() option.Option[Expr] {
	found := false
	for _, child := range node.children() {
		if found {
			return SyntaxNode_cast[Expr](child)
		}
		if child.kind() == SyntaxKindIf {
			found = true
		}
	}
	return option.None[Expr]()
}

// --- [ ShowRule ] ------------------------------------------------------------

// A show rule: `show heading: it => emph(it.body)`.
type ShowRule struct {
	*SyntaxNode
}

// Defines which nodes the show rule applies to.
func (node *ShowRule) selector() option.Option[Expr] {
	children := node.children()
	found := false
	for _, child := range slices.Backward(children) {
		if found {
			return SyntaxNode_cast[Expr](child)
		}
		if child.kind() == SyntaxKindColon {
			found = true
		}
	}
	return option.None[Expr]()
}

// The transformation recipe.
func (node *ShowRule) transform() Expr {
	return SyntaxNode_cast_last[Expr](node.SyntaxNode)
}

// --- [ Contextual ] ----------------------------------------------------------

// A contextual expression: `context text.lang`.
type Contextual struct {
	*SyntaxNode
}

// The expression which depends on the context.
func (node *Contextual) body() Expr {
	return SyntaxNode_cast_first[Expr](node.SyntaxNode)
}

// --- [ Conditional ] ---------------------------------------------------------

// An if-else conditional: `if x { y } else { z }`.
type Conditional struct {
	*SyntaxNode
}

// The condition which selects the body to evaluate.
func (node *Conditional) condition() Expr {
	return SyntaxNode_cast_first[Expr](node.SyntaxNode)
}

// The expression to evaluate if the condition is true.
func (node *Conditional) if_body() Expr {
	i := 0
	for _, child := range node.children() {
		if expr, ok := SyntaxNode_cast[Expr](child).Get(); ok {
			if i == 1 {
				return expr
			}
			i++
		}
	}
	// TODO: report warning?
	return Expr_default() // default value
}

// The expression to evaluate if the condition is false.
func (node *Conditional) else_body() option.Option[Expr] {
	i := 0
	for _, child := range node.children() {
		if expr, ok := SyntaxNode_cast[Expr](child).Get(); ok {
			if i == 2 {
				return option.Some(expr)
			}
			i++
		}
	}
	return option.None[Expr]()
}

// --- [ WhileLoop ] -----------------------------------------------------------

// A while loop: `while x { y }`.
type WhileLoop struct {
	*SyntaxNode
}

// The condition which selects whether to evaluate the body.
func (node *WhileLoop) condition() Expr {
	return SyntaxNode_cast_first[Expr](node.SyntaxNode)
}

// The expression to evaluate while the condition is true.
func (node *WhileLoop) body() Expr {
	return SyntaxNode_cast_last[Expr](node.SyntaxNode)
}

// --- [ ForLoop ] -------------------------------------------------------------

// A for loop: `for x in y { z }`.
type ForLoop struct {
	*SyntaxNode
}

// TODO: use pointer to Pattern? Are Param Patterns and for loop Patterns the
// same?

// The pattern to assign to.
func (node *ForLoop) pattern() Pattern {
	return SyntaxNode_cast_first[Pattern](node.SyntaxNode)
}

// The expression to iterate over.
func (node *ForLoop) iterable() Expr {
	found := false
	for _, child := range node.children() {
		if found {
			if expr, ok := SyntaxNode_cast[Expr](child).Get(); ok {
				return expr
			} else {
				return Expr_default() // default value
			}
		}
		if child.kind() == SyntaxKindIn {
			found = true
		}
	}
	return Expr_default()
}

// The expression to evaluate for each iteration.
func (node *ForLoop) body() Expr {
	return SyntaxNode_cast_last[Expr](node.SyntaxNode)
}

// --- [ ModuleImport ] --------------------------------------------------------

// A module import: `import "utils.typ": a, b, c`.
type ModuleImport struct {
	*SyntaxNode
}

// The module or path from which the items should be imported.
func (node *ModuleImport) source() Expr {
	return SyntaxNode_cast_first[Expr](node.SyntaxNode)
}

// The items to be imported.
func (node *ModuleImport) imports() option.Option[Imports] {
	for _, child := range node.children() {
		switch child.kind() {
		case SyntaxKindStar:
			return option.Some[Imports](&Imports_Wildcard{})
		case SyntaxKindImportItems:
			if items, ok := SyntaxNode_cast[*ImportItems](child).Get(); ok {
				return option.Some[Imports](&Imports_Items{items: items})
			}
		}
	}
	return option.None[Imports]()
}

// The name that will be bound for a bare import. This name must be
// statically known. It can come from:
//   - an identifier
//   - a field access
//   - a string that is a valid file path where the file stem is a valid
//     identifier
//   - a string that is a valid package spec
func (node *ModuleImport) bare_name() (string, error) {
	source := node.source()
	switch source := source.(type) {
	case *Ident:
		return source.get(), nil
	case *FieldAccess:
		return source.field().get(), nil
	case *Str:
		str := source.get()
		var name string
		if strings.HasPrefix(str, "@") {
			spec, err := ParsePackageSpec(str)
			if err != nil {
				return "", ErrBareImport_PackageInvalid // TODO: also report err as warning?
			}
			name = spec.Name
		} else {
			file_name := filepath.Base(str)
			ext := filepath.Ext(file_name)
			file_stem := strings.TrimSuffix(file_name, ext) // trim ext
			name = file_stem
		}

		if !isIdent(name) {
			return "", ErrBareImport_PathInvalid
		}

		return name, nil
	default:
		return "", ErrBareImport_Dynamic
	}
}

// The name this module was assigned to, if it was renamed with `as`
// (`renamed` in `import "..." as renamed`).
func (node *ModuleImport) new_name() option.Option[*Ident] {
	found := false
	for _, child := range node.children() {
		if found {
			SyntaxNode_cast[*Ident](child)
		}
		if child.kind() == SyntaxKindAs {
			found = true
		}
	}
	return option.None[*Ident]()
}

// Reasons why a bare name cannot be determined for an import source.
//
// BareImportError
var (
	// There is no statically resolvable binding name.
	ErrBareImport_Dynamic = errors.New("there is no statically resolvable binding name")
	// The import source is not a valid path or the path stem not a valid
	// identifier.
	ErrBareImport_PathInvalid = errors.New("the import source is not a valid path or the path stem not a valid identifier")
	// The import source is not a valid package spec.
	ErrBareImport_PackageInvalid = errors.New("the import source is not a valid package spec")
)

// The items that ought to be imported from a file.
type Imports interface {
	isImports()
}

func (*Imports_Wildcard) isImports() {}
func (*Imports_Items) isImports()    {}

// All items in the scope of the file should be imported.
//
// Wildcard
type Imports_Wildcard struct {
}

// The specified items from the file should be imported.
//
// Items
type Imports_Items struct {
	items *ImportItems
}

// --- [ ImportItems ] ---------------------------------------------------------

// Items to import from a module: `a, b, c`.
type ImportItems struct {
	*SyntaxNode
}

// Returns an iterator over the items to import from the module.
func (node *ImportItems) iter() []ImportItem {
	var items []ImportItem
	for _, child := range node.children() {
		switch child.kind() {
		case SyntaxKindRenamedImportItem:
			if _item, ok := SyntaxNode_cast[*RenamedImportItem](child).Get(); ok {
				item := &ImportItem_Renamed{
					renamed_item: _item,
				}
				items = append(items, item)
			}
		case SyntaxKindImportItemPath:
			if _item, ok := SyntaxNode_cast[*ImportItemPath](child).Get(); ok {
				item := &ImportItem_Simple{
					_path: _item,
				}
				items = append(items, item)
			}
		}
	}
	return items
}

// --- [ ImportItemPath ] ------------------------------------------------------

// A path to a submodule's imported name: `a.b.c`.
type ImportItemPath struct {
	*SyntaxNode
}

// An iterator over the path's components.
func (node *ImportItemPath) iter() []*Ident {
	var idents []*Ident
	for _, child := range node.children() {
		if ident, ok := SyntaxNode_cast[*Ident](child).Get(); ok {
			idents = append(idents, ident)
		}
	}
	return idents
}

// The name of the imported item. This is the last segment in the path.
func (node *ImportItemPath) name() *Ident {
	return SyntaxNode_cast_last[*Ident](node.SyntaxNode)
}

// An imported item, potentially renamed to another identifier.
type ImportItem interface {
	isImportItem()

	// The path to the imported item.
	path() *ImportItemPath
	// The original name of the imported item, at its source. This will be the
	// equal to the bound name if the item wasn't renamed with 'as'.
	original_name() *Ident
	// The name which this import item was bound to. Corresponds to the new
	// name, if it was renamed; otherwise, it's just its original name.
	bound_name() *Ident
}

func (*ImportItem_Simple) isImportItem()  {}
func (*ImportItem_Renamed) isImportItem() {}

// A non-renamed import (the item's name in the scope is the same as its name).
//
// Simple
type ImportItem_Simple struct {
	_path *ImportItemPath
}

// A renamed import (the item was bound to a different name in the scope
// than the one it was defined as).
//
// Renamed
type ImportItem_Renamed struct {
	renamed_item *RenamedImportItem
}

// The path to the imported item.
func (item *ImportItem_Simple) path() *ImportItemPath {
	return item._path
}

// The path to the imported item.
func (item *ImportItem_Renamed) path() *ImportItemPath {
	return item.renamed_item.path()
}

// The original name of the imported item, at its source. This will be the
// equal to the bound name if the item wasn't renamed with 'as'.
func (item *ImportItem_Simple) original_name() *Ident {
	return item._path.name()
}

// The original name of the imported item, at its source. This will be the
// equal to the bound name if the item wasn't renamed with 'as'.
func (item *ImportItem_Renamed) original_name() *Ident {
	return item.renamed_item.original_name()
}

// The name which this import item was bound to. Corresponds to the new
// name, if it was renamed; otherwise, it's just its original name.
func (item *ImportItem_Simple) bound_name() *Ident {
	return item._path.name()
}

// The name which this import item was bound to. Corresponds to the new
// name, if it was renamed; otherwise, it's just its original name.
func (item *ImportItem_Renamed) bound_name() *Ident {
	return item.renamed_item.new_name()
}

// --- [ RenamedImportItem ] ---------------------------------------------------

// A renamed import item: `a as d`
type RenamedImportItem struct {
	*SyntaxNode
}

// The path to the imported item.
func (node *RenamedImportItem) path() *ImportItemPath {
	return SyntaxNode_cast_first[*ImportItemPath](node.SyntaxNode)
}

// The original name of the imported item (`a` in `a as d` or `c.b.a as d`).
func (node *RenamedImportItem) original_name() *Ident {
	return node.path().name()
}

// The new name of the imported item (`d` in `a as d`).
func (node *RenamedImportItem) new_name() *Ident {
	return SyntaxNode_cast_last[*Ident](node.SyntaxNode)
}

// --- [ ModuleInclude ] -------------------------------------------------------

// A module include: `include "chapter1.typ"`.
type ModuleInclude struct {
	*SyntaxNode
}

// The module or path from which the content should be included.
func (node *ModuleInclude) source() Expr {
	return SyntaxNode_cast_last[Expr](node.SyntaxNode)
}

// --- [ LoopBreak ] -----------------------------------------------------------

// A break from a loop: `break`.
type LoopBreak struct {
	*SyntaxNode
}

// --- [ LoopContinue ] --------------------------------------------------------

// A continue in a loop: `continue`.
type LoopContinue struct {
	*SyntaxNode
}

// --- [ FuncReturn ] ----------------------------------------------------------

// A return from a function: `return`, `return x + 1`.
type FuncReturn struct {
	*SyntaxNode
}

// The expression to return.
func (node *FuncReturn) body() option.Option[Expr] {
	return SyntaxNode_try_cast_last[Expr](node.SyntaxNode)
}
